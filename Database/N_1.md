## 외래키 (to, on_delete)
- 한 모델이 다른 모델을 참조하는 관계 설정하는 필드
- N:1 관계 표현
- to는 참조하는 모델 class 이름, on_delete는 참조하던 객체가 사라졌을 때 외래키를 어떻게 처리할지 속성
  - CASCADE : 부모 객체 삭제되면 참조하는 객체도 삭제
  - PROTECT : 부모 객체를 삭제하지 못하도록
  - SET_NULL : 부모 객체 삭제되면 NULL이 저장되도록

### 댓글 생성 연습 (Comment(N) : Article(1))
1. 댓글 생성 후 바로 저장 확인
```
# django shell 실행
$ python manage.py shell

# 게시글 생성
Article.objects.create(title='title', content='content')

# Comment 클래스의 인스턴스 comment 생성
comment = Comment()

# 인스턴스 변수 저장
comment.content = 'first comment'

# DB에 댓글 저장
comment.save()
```

2. 게시글 정보를 가져와 댓글 저장
```
# 게시글 정보 조회하여 가져오기
article = Article.objects.get(pk=1)

# 외래 키 데이터 입력
comment.article = article

# 댓글 저장 및 확인
comment.save()
```

3. comment 인스턴스를 통한 article 값 참조하기
```
comment.pk # 1
comment.content # 'first comment'
comment.article # <Article: Article object (1)>
comment.article_id # 1
```

4. comment를 통한 article 객체의 데이터 참조하기
```
comment.article.pk # 1
comment.article.content # 'content'
```

5. 두번째 댓글 생성 및 데이터 확인
```
commentary = Comment(content='second comment', article=article)
commentary.save()

commentary.pk # 2
commentary # <Comment: Comment object (2)>
commentary.article.pk # 1
```
---

## 참조
직접 대상의 정보 저장, 필요할 때 활용
- 특정 게시글(Article)의 댓글(Comment) 정보 조회하기 : **QuerySet API의 .filter()** 사용하기
```
article = Article.objects.get(pk=1)
comments = Comment.objects.filter(article=article)
```

---

## 역참조 
누가 나를 참조하는지 거꾸로 조회하는 것
### `article.comment_set.all()`
- related manager 연습
```
$ python manage.py shell

# 1번 게시글 조회
article = Article.objects.get(pk=1)

# 1번 게시글에 작성된 모든 댓글 조회하기 (역참조)
article.comment_set.all()

# 1번 게시글에 작성된 모든 댓글 내용 출력
comments = article.comment_set.all()

# 1번 게시글 댓글 정보를 반복하여 개별 출력
for comment in comments:
  print(comment.content)
```

- 댓글 CREATE 구현
```
# articles/forms.py
from .models import Article, Comment

class CommentForm(forms.ModelForm):
  class Meta:
    model = Comment
    fields = ('content', ') # 외래 키 필드가 출력되지않도록
```
```
# articles/views.py
def detail(request, pk):
  article = Article.objects.get(pk=pk)
  comment_form = CommentForm()
  context = {
    'article': article,
    'comment_form': comment_form,
  }
  return render(request, 'articles/detail.html', context)
```
```
# articles/detail.html
<form action="{% url 'articles:comments_create' article.pk %}" method=POST">
  {% csrf_token %}
  {{ comment_form }}
  <input type="submit">
</form>

# articles/urls.py
app_name = 'article'
urlpatterns = [
  path('<int:pk>/comments/', views.comments_create, name='comments_create'),
]
```
```
# articles/views.py
def comments_create(request, pk):
  article = Article.objects.get(pk=pk)
  comment_form = CommentForm(request.POST)

  if comment_form.is_valid():
    # 댓글을 저장하지 않고 인스턴스만 생성
    comment = comment_form.save(commit=False)
    # 댓글에 게시글 정보 추가
    comment.article = article
    # 댓글 정보 DB에 저장 요청
    comment.save()
    return redirect('articles:detail', article.pk)

  context = {
    'article' : article,
    'comment_form' : comment_form,
  }

  return render(request, 'articles/detail.html', context)
```
---
- 댓글 READ 구현
```
# articles/views.py
def detail(request, pk):
  article = Article.objects.get(pk=pk)
  comment_form = CommentForm()
  
  # 특정 게시글의 댓글을 역참조로 조회
  comments = article.comment_set.all()
  context = {
    'article': article,
    'comment_form': comment_form,
    'comments': comments,
  }
  return render(request, 'articles/detail.html', context)
```

---

- 댓글 DELETE 구현
```
# articles/urls.py
app_name = 'article'
urlpatterns = [
  path(
    '<int:article_pk>/comments/<int:comment_pk>/delete/', 
    views.comments_delete, name='comments_delete'
  ),
]
```
```
# articles/views.py
def comments_delete(request, article_pk, comment_pk):
  comment = Comment.objects.get(pk=comment_pk)
  comment.delete()
  return redirect('articles:detail', article_pk)
```