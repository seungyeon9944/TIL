**타입** : 변수나 값이 가질 수 있는 데이터의 종류 (어떤 종류의 데이터인지, 어떻게 해석되고 처리되어야하는지를 정의) 
1)	**값(피연산자)**
2)	**연산자**

데이터 타입 : 값의 종류와 그 값으로 할 수 있는 ‘동작(연산)’을 결정하는 속성

1. **Numeric Types** : 
int(정수), float(실수), complex(복소수)

2. **Text Sequence Type** : 
str(문자열)

3. **Sequence Type** :
list, tuple, range
시퀀스, 여러 데이터가 정해진 순서대로 일렬로 늘어선 자료 구조
모든 칸에는 0번부터 시작하는 고유한 번호(인덱스)가 붙어 있음
공통 특징 : 
1) 순서(Order) 
2) 인덱싱(Indexing) 
3) 슬라이싱(Slicing) 
4) 길이(Length) 
5) 반복(Iteration): 

4. **Non-sequence Type** : 
set, dict

5. **Boolean, None, Functions**

# Collection 
| 컬렉션명 | 변경 가능 여부 | 순서 존재 여부 |
| --- | --- | --- |
| str | X | O
| list | O | O
| tuple | X | O
| dict | O | X
| set | O | X

# 형변환 
Basic_Syntax_02 파일부터 정리 ! 

---
---

### 숫자형 데이터  
1) **정수형(int)** 
2) **실수형(float)** - 지수 표현법 (‘e’ 또는 ‘E’ 사용)
산술연산자 표
연산자 우선순위 : ** > -(음수부호) > *, /, //, % > +, -


연산자 우선순위
| 우선순위 | 연산자 | 연산 |
| --- | --- | --- |
| 높음 | ** | 지수
|   | - | 음수 부호
|   | *, /, //, % | 곱셈, 나눗셈, 정수 나눗셈, 나머지
| 낮음 | +, - | 덧셈, 뺄셈

---

# 문자열 str
문자들의 순서가 있는 변경 불가능한 시퀀스 자료형
- 이스케이프 시퀀스 : 역슬래시 (\)와 문자를 조합해 특별한 기능을 수행.
ex. `print(‘He\’s a boy.’)`
- **f-string** : 문자열 내에 변수나 표현식의 결과를 손쉽게 삽입 
ex. `greeting = **f**’안녕하세요, 제 이름은 **{name}**이고 나이는 **{age}**입니다.’`

1)	인덱스 (0부터 시작)

2)	슬라이싱 (시퀀스의 일부분을 잘라내어 새로운 시퀀스 생성)
`my_sequence[start:stop:step], my_sequence[start:stop], my_sequence[::stop]`
음수 인덱스의 경우 방향 바꿀 수 있음. `my_str[::-1]` 하면 olleh

3)	문자열의 불변성 

+ 정수형의 진법 표현
2진수 print(**0b**10), 8진수 print(**0o**30). 16진수 print(**0x**10)

+ 부동소수점 (반올림) 오차 : 무한소수의 발생과 근사값 저장, 미세한 오차 발생
decimal

---

# Sequence 
시퀀스, 여러 데이터가 정해진 순서대로 일렬로 늘어선 자료 구조

**Types** : 여러 개의 값들을 순서대로 나열하여 저장하는 자료형. 
모든 칸에는 0번부터 시작하는 고유한 번호(인덱스)가 붙어 있음
공통 특징 : 
1) 순서(Order) 
2) 인덱싱(Indexing) 
3) 슬라이싱(Slicing) 
4) 길이(Length) 
5) 반복(Iteration)

---

# Boolean
‘참(True)’과 ‘거짓(False)’ 단 두 가지 값만을 가지는 데이터 타입

---

# None
파이썬에서 ‘값이 없음’을 표현하는 데이터 타입

---

# 1. 리스트 List
여러 개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료형
숫자, 문자열, 심지어 다른 리스트까지 모든 종류의 데이터를 담을 수 있음
ex. `[1, 2, 3, ‘Python’, [‘hello’, ‘world’]]`
시퀀스 특징 : 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통기능 모두 사용


- **중첩 리스트 (Nested List)** : 다른 리스트를 값으로 가진 리스트
ex. `print(my_list[-1][1][0]) = w` (문자열 하나만 뽑아내기도 함)

- 리스트의 **가변성** : 내용을 자유롭게 수정, 추가, 삭제할 수 있음 
(문자열의 불변성과 정반대됨 ! 다중할당과 값 교환 때 쓰임)
1)	인덱싱으로 값 수정하기
2)	슬라이싱으로 여러 값 한번에 바꾸기

---


### 오답노트 📝💯
- 0이 250000개 있는 리스트 만들기 

ex. `many_zero_list = '0'*250000`

---

### ✏️ **얕은복사의 오류**

`import copy`
`backup_catalog = copy.deepcopy(catalog)`
하면 backup_catalog은 catalog가 변해도 변하지않음


### 1. assignment 할당
`a_list = [1,2,3]`

`b_list = a_list`

이때 `b_list`의 결과는 `[1,2,3]`

---

### 2. shallow copy 얕은복사
`a_list = [1,2,3]`

`b_list = a_list[:]` slicing은 연산자여서 list에 있는 데이터를 갖고와서 넣어주는거라 a_list가 변화해도 변하지않음 (반영x )

`a_list[0] = 100 ` 새로운 데이터 주소를 가리키기 때문, 별도의 리스트가 됨

`print(b_list[0])` 의 결과는 `1`

---

## ✏️ shallow copy problem 얕은복사의 문제점
`a_list = [
    [1,2],
    [3,4],
]`

`b_list = a_list[:]`


`a_list[0] = [5,6]`

`a_list[1][0] = 7`

`print(b_list[0])`의 결과는 `1,2`

`print(b_list[1][0])`의 결과는 `7`

<img width="985" height="376" alt="Image" src="https://github.com/user-attachments/assets/60d018f7-f89c-437a-a2a0-36c67ea9169f" />

---

### 형변환 Type Conversion
- 암시적 형변환 (자동으로 데이터 타입을 변환)
ex. 정수 + 실수 = 실수. 불리언 + 정수 = T는 1 + 정수로 계산, 불리언간의 덧셈 T + F = 1 + 0 = 1
- 명시적 형변환 (직접 함수로 지정하여 변환)

## 연산자

**복합 연산자**

**비교 연산자**
- is 연산자 -> 똑 같은 것인지 비교. 잘 사용하지 않으나 주로 싱글톤 객체(오직 1개만 존재하도록 만들어짐, None True False) 비교할 때 씀
- == 연산자

**논리 연산자** - 단축 평가 (논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작)

**멤버십 연산자**

**시퀀스형 연산자**

### Trailing Comma
ex.
`s = ['a',`
    ` 'b',`
   `  'c',`
`]`

---

# range 
연속된 정수 시퀀스를 생성하는, **변경 불가능한(immutable)** 자료형
- 주로 반복문과 함께 사용
`range(stop)`
`range(start, stop)`
`range(start, stop, step)`

ex. `my_range_1 = range(5)`
`print(list(my_range_1))` 해줘야 `[0, 1, 2, 3, 4]`가 나옴

---

# dictionary 딕셔너리
key - value 쌍으로 이루어진 **순서와 중복이 없는 변경 가능한** 자료형
{‘apple’: 12, ‘list’: [1,2,3]}

- 키 중복 불가
- 딕셔너리 규칙
1) Key의 규칙 : 고유해야 하고 변경불가능한(immutable) 자료형만 사용 가능
2) Value의 규칙 : 어떤 자료형이든 자유롭게 사용할 수 있음
3) Key에 접근하여 대괄호 [ ] 사용해서 해당 Value를 꺼내옴



### 오답노트 📝💯
✏️ dict처럼 보이지만 str가 섞여있는 경우가 있음 ! 

ex. `data = [{'가':'A', '나':'B', '다':[{'ㄱ':'a'}]}]`일 때 'a'를 뽑아내려면 `data[0]['다'][0]['ㄱ']` << 이렇게 적어야함

✏️ 마지막 딕셔너리 형식 출력에 맞게 바꾸기

ex. `for k, v in informations. items():`
    `print("{}:{}".format(k,v))`


---

# 튜플 tuple
여러 개의 값을 순서대로 저장하는 **변경 불가능**한 시퀀스 자료형
`my_tuple_1 = (1, ‘a’, 3, ‘b’)`
`my_tuple_2 = 1, ‘a’, 3, ‘b’`
`my_tuple_3 = (1,)` <- 단일튜플 만들 때는 **Trailing comma (후행 쉼표)** 사용해야 

시퀀스 특징 : 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능 사용가능

---

# set 세트
**순서와 중복이 없는 변경 가능한** 자료형
집합처럼 사용 (합집합 | 차집합 - 교집합 &)

